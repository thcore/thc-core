export const auth = {
    // 필요한 메서드들만 모킹
    signInWithEmailAndPassword: jest.fn(),
    signOut: jest.fn(),
    onAuthStateChanged: jest.fn()
  };
  
  export const app = {
    // 필요한 경우 추가
  };import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginForm from '@/components/auth/LoginForm';
import { useAuth } from '@/hooks/useAuth';
import { FirebaseError } from 'firebase/app';

// Firebase 모킹
jest.mock('@/lib/firebase', () => ({
  auth: {
    signInWithEmailAndPassword: jest.fn(),
    signOut: jest.fn(),
    onAuthStateChanged: jest.fn()
  }
}));

// useAuth 훅 모킹
jest.mock('@/hooks/useAuth');

describe('LoginForm', () => {
  const mockLogin = jest.fn();
  const user = userEvent.setup();
  
  beforeEach(() => {
    (useAuth as jest.Mock).mockReturnValue({
      login: mockLogin
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  /**
   * 초기 렌더링 테스트
   */
  describe('Initial Render', () => {
    it('renders all form elements correctly', () => {
      render(<LoginForm />);
      
      expect(screen.getByLabelText('이메일')).toBeInTheDocument();
      expect(screen.getByLabelText('비밀번호')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: '로그인' })).toBeInTheDocument();
    });

    it('starts with empty form fields', () => {
      render(<LoginForm />);
      
      expect(screen.getByLabelText('이메일')).toHaveValue('');
      expect(screen.getByLabelText('비밀번호')).toHaveValue('');
    });

    it('starts with disabled submit button', () => {
      render(<LoginForm />);
      
      expect(screen.getByRole('button', { name: '로그인' })).toBeDisabled();
    });
  });

  /**
   * 입력 유효성 검사 테스트
   */
  describe('Input Validation', () => {
    it('validates email format', async () => {
      render(<LoginForm />);
      const emailInput = screen.getByLabelText('이메일');
      
      // 잘못된 이메일 형식
      await user.type(emailInput, 'invalid-email');
      await user.tab();
      expect(screen.getByText('유효한 이메일 주소를 입력해주세요')).toBeInTheDocument();
      
      // 올바른 이메일 형식
      await user.clear(emailInput);
      await user.type(emailInput, 'test@example.com');
      await user.tab();
      expect(screen.queryByText('유효한 이메일 주소를 입력해주세요')).not.toBeInTheDocument();
    });

    it('validates password length', async () => {
      render(<LoginForm />);
      const passwordInput = screen.getByLabelText('비밀번호');
      
      // 짧은 비밀번호
      await user.type(passwordInput, '12345');
      await user.tab();
      expect(screen.getByText('비밀번호는 최소 6자 이상이어야 합니다')).toBeInTheDocument();
      
      // 올바른 길이의 비밀번호
      await user.clear(passwordInput);
      await user.type(passwordInput, '123456');
      await user.tab();
      expect(screen.queryByText('비밀번호는 최소 6자 이상이어야 합니다')).not.toBeInTheDocument();
    });
  });

  /**
   * 폼 제출 테스트
   */
  describe('Form Submission', () => {
    it('handles successful login', async () => {
      // mockLogin이 Promise를 반환하도록 설정
      mockLogin.mockImplementation(() => new Promise(resolve => setTimeout(resolve, 100)));
      render(<LoginForm />);
      
      await user.type(screen.getByLabelText('이메일'), 'test@example.com');
      await user.type(screen.getByLabelText('비밀번호'), 'password123');
      
      const submitButton = screen.getByRole('button', { name: '로그인' });
      await user.click(submitButton);
      
      // 로딩 상태 확인 전에 대기
      await waitFor(() => {
        expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password123');
        expect(submitButton).toHaveAttribute('aria-busy', 'true');
        expect(screen.getByText('로그인 중...')).toBeInTheDocument();
      });
    });

    it('handles invalid credentials', async () => {
      mockLogin.mockRejectedValueOnce(new FirebaseError('auth/invalid-credential', ''));
      
      render(<LoginForm />);
      
      await user.type(screen.getByLabelText('이메일'), 'test@example.com');
      await user.type(screen.getByLabelText('비밀번호'), 'wrongpassword');
      await user.click(screen.getByRole('button', { name: '로그인' }));
      
      await waitFor(() => {
        expect(screen.getByText('이메일 또는 비밀번호가 올바르지 않습니다')).toBeInTheDocument();
      });
    });

    it('handles too many requests error', async () => {
      mockLogin.mockRejectedValueOnce(new FirebaseError('auth/too-many-requests', ''));
      
      render(<LoginForm />);
      
      await user.type(screen.getByLabelText('이메일'), 'test@example.com');
      await user.type(screen.getByLabelText('비밀번호'), 'password123');
      await user.click(screen.getByRole('button', { name: '로그인' }));
      
      await waitFor(() => {
        expect(screen.getByText('너무 많은 로그인 시도가 있었습니다. 잠시 후 다시 시도해주세요')).toBeInTheDocument();
      });
    });

    it('handles network errors', async () => {
      mockLogin.mockRejectedValueOnce(new FirebaseError('auth/network-request-failed', ''));
      
      render(<LoginForm />);
      
      await user.type(screen.getByLabelText('이메일'), 'test@example.com');
      await user.type(screen.getByLabelText('비밀번호'), 'password123');
      await user.click(screen.getByRole('button', { name: '로그인' }));
      
      await waitFor(() => {
        expect(screen.getByText('네트워크 연결을 확인해주세요')).toBeInTheDocument();
      });
    });
  });

  /**
   * 접근성 테스트
   */
  describe('Accessibility', () => {
    it('has proper ARIA attributes', async () => {
      render(<LoginForm />);
      const emailInput = screen.getByLabelText('이메일');
      
      // 잘못된 이메일 입력
      await user.type(emailInput, 'invalid-email');
      await user.tab();
      
      // 유효성 검사 결과 확인
      await waitFor(() => {
        expect(emailInput).toHaveAttribute('aria-invalid', 'true');
        expect(emailInput).toHaveAttribute('aria-describedby');
      });
    });

    it('has correct tab order', () => {
      render(<LoginForm />);
      
      const emailInput = screen.getByLabelText('이메일');
      const passwordInput = screen.getByLabelText('비밀번호');
      const submitButton = screen.getByRole('button', { name: '로그인' });
      
      // 올바른 순서로 요소들이 존재하는지 확인
      expect(emailInput).toBeInTheDocument();
      expect(passwordInput).toBeInTheDocument();
      expect(submitButton).toBeInTheDocument();
      
      // tabIndex 확인
      expect(emailInput).not.toHaveAttribute('tabindex', '-1');
      expect(passwordInput).not.toHaveAttribute('tabindex', '-1');
      expect(submitButton).not.toHaveAttribute('tabindex', '-1');
    });
  });
});'use client'

import { 
  BanknotesIcon, 
  ClockIcon, 
  DocumentIcon, 
  UserGroupIcon 
} from '@heroicons/react/24/outline'
import Card from '@/components/common/Card'
import ContentHeader from '@/components/common/ContentHeader'

export default function DashboardPage() {
  const stats = [
    {
      name: '이번 달 청구 금액',
      value: '₩2,450,000',
      change: '+12.5%',
      changeType: 'positive',
      icon: BanknotesIcon,
    },
    {
      name: '처리 대기 중',
      value: '4건',
      change: '-10%',
      changeType: 'negative',
      icon: ClockIcon,
    },
    {
      name: '이번 달 청구 건수',
      value: '24건',
      change: '+3건',
      changeType: 'positive',
      icon: DocumentIcon,
    },
    {
      name: '팀 구성원',
      value: '12명',
      change: '+2명',
      changeType: 'positive',
      icon: UserGroupIcon,
    },
  ]

  return (
    <div className="space-y-[var(--layout-spacing-section)]">
      <ContentHeader
        title="대시보드"
        description="전체 현황을 한눈에 확인하세요."
      />

      {/* 통계 카드 */}
      <div className="grid grid-cols-1 gap-[var(--grid-spacing-lg)] sm:grid-cols-2 lg:grid-cols-4">
        {stats.map((stat) => (
          <Card key={stat.name} variant="elevated" padding="md">
            <div className="flex items-center">
              <div className="flex-shrink-0">
                <stat.icon className="h-6 w-6 text-[var(--colors-action-primary)]" aria-hidden="true" />
              </div>
              <div className="ml-[var(--element-spacing-lg)]">
                <p className="text-sm font-medium text-[var(--colors-text-secondary)]">{stat.name}</p>
                <div className="flex items-baseline">
                  <p className="text-2xl font-semibold text-[var(--colors-text-primary)]">{stat.value}</p>
                  <p
                    className={`ml-[var(--element-spacing-md)] flex items-baseline text-sm font-semibold ${
                      stat.changeType === 'positive' ? 'text-[var(--colors-success-500)]' : 'text-[var(--colors-danger-500)]'
                    }`}
                  >
                    {stat.change}
                  </p>
                </div>
              </div>
            </div>
          </Card>
        ))}
      </div>

      {/* 최근 활동 */}
      <section className="space-y-[var(--component-spacing-md)]">
        <div>
          <h2 className="text-xl font-semibold text-[var(--colors-text-primary)]">최근 활동</h2>
        </div>
        <Card variant="elevated" padding="md">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-[var(--colors-border-default)]">
              <thead>
                <tr>
                  <th className="px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-left text-sm font-medium text-[var(--colors-text-secondary)]">날짜</th>
                  <th className="px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-left text-sm font-medium text-[var(--colors-text-secondary)]">활동</th>
                  <th className="px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-left text-sm font-medium text-[var(--colors-text-secondary)]">상태</th>
                  <th className="px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-left text-sm font-medium text-[var(--colors-text-secondary)]">금액</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-[var(--colors-border-default)]">
                {/* 활동 데이터 매핑 */}
              </tbody>
            </table>
          </div>
        </Card>
      </section>
    </div>
  )
}'use client'

import { useAuth } from '@/hooks/useAuth'
import { useEffect } from 'react'
import LoadingSpinner from '@/components/common/LoadingSpinner'
import { useRouter } from 'next/navigation'

export default function AuthHome() {
  const { user, loading } = useAuth()
  const router = useRouter()

  useEffect(() => {
    if (!loading && user) {
      // 로그인된 상태면 대시보드로 리다이렉트
      router.push('/dashboard')
    }
  }, [user, loading, router])

  if (loading) {
    return <LoadingSpinner size="lg" text="로딩 중..." />
  }

  return null
}import { Metadata } from 'next'

export const metadata: Metadata = {
  title: '결재 요청 - THC Core',
  description: '새로운 결재 요청을 생성합니다.',
}'use client'

import PaymentRequestForm from '@/components/payment/PaymentRequestForm'
import LoadingSpinner from '@/components/common/LoadingSpinner'
import ContentHeader from '@/components/common/ContentHeader'
import { useAuth } from '@/hooks/useAuth'

export default function PaymentRequestPage() {
  const { loading } = useAuth()

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <LoadingSpinner size="lg" text="로딩 중..." />
      </div>
    )
  }
  
  return (
    <div className="space-y-[var(--layout-spacing-section)]">
      <ContentHeader
        title="비용 청구"
        description="비용 청구 내역을 작성하세요."
      />

      <section className="space-y-[var(--component-spacing-md)]">
        <div>
          <h2 className="text-xl font-semibold text-[var(--colors-text-primary)]">청구 정보</h2>
        </div>
        <div>
          <PaymentRequestForm />
        </div>
      </section>
    </div>
  )
}
/* Pretendard 폰트 */
@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* 라이트 테마 (기본) */
:root {
  /* Base Colors */
  --colors-primary-50: #e6f7ff;
  --colors-primary-100: #bae7ff;
  --colors-primary-200: #91d5ff;
  --colors-primary-300: #69c0ff;
  --colors-primary-400: #40a9ff;
  --colors-primary-500: #1890ff;
  --colors-primary-600: #096dd9;
  --colors-primary-700: #0050b3;
  --colors-primary-800: #003a8c;
  --colors-primary-900: #002766;

  --colors-neutral-50: #fafafa;
  --colors-neutral-100: #f5f5f5;
  --colors-neutral-150: #f0f0f0;  /* 미세 구분 추가 */
  --colors-neutral-200: #e8e8e8;
  --colors-neutral-250: #e0e0e0;  /* 미세 구분 추가 */
  --colors-neutral-300: #d9d9d9;
  --colors-neutral-400: #bfbfbf;
  --colors-neutral-500: #8c8c8c;
  --colors-neutral-600: #595959;
  --colors-neutral-650: #525252;  /* 미세 구분 추가 */
  --colors-neutral-700: #434343;
  --colors-neutral-750: #383838;  /* 미세 구분 추가 */
  --colors-neutral-800: #262626;
  --colors-neutral-900: #1f1f1f;

  /* Semantic Colors - 단계 보강 */
  --colors-success-50: #f6ffed;
  --colors-success-100: #d9f7be;
  --colors-success-200: #b7eb8f;  /* 약한 성공 */
  --colors-success-300: #95de64;  /* 보통 성공 */
  --colors-success-400: #73d13d;  /* 강한 성공 */
  --colors-success-500: #52c41a;
  --colors-success-600: #389e0d;
  --colors-success-700: #237804;

  --colors-warning-50: #fffbe6;
  --colors-warning-100: #fff1b8;
  --colors-warning-200: #ffd666;  /* 약한 경고 */
  --colors-warning-300: #ffc53d;  /* 보통 경고 */
  --colors-warning-400: #faad14;  /* 강한 경고 */
  --colors-warning-500: #d48806;
  --colors-warning-600: #ad6800;
  --colors-warning-700: #874d00;

  --colors-danger-50: #fff1f0;
  --colors-danger-100: #ffccc7;
  --colors-danger-200: #ffa39e;  /* 약한 위험 */
  --colors-danger-300: #ff7875;  /* 보통 위험 */
  --colors-danger-400: #ff4d4f;  /* 강한 위험 */
  --colors-danger-500: #f5222d;
  --colors-danger-600: #cf1322;
  --colors-danger-700: #a8071a;

  /* Contextual Colors */
  --colors-background-primary: var(--colors-neutral-50);
  --colors-background-secondary: var(--colors-neutral-100);
  --colors-background-tertiary: var(--colors-neutral-200);
  --colors-background-emphasis: var(--colors-primary-50);
  --colors-background-disabled: var(--colors-neutral-100);
  --colors-background-overlay: rgba(0, 0, 0, 0.45);
  --colors-background-spotlight: var(--colors-primary-900);

  --colors-text-primary: var(--colors-neutral-900);
  --colors-text-secondary: var(--colors-neutral-600);
  --colors-text-tertiary: var(--colors-neutral-500);
  --colors-text-disabled: var(--colors-neutral-400);
  --colors-text-inverse: var(--colors-neutral-50);
  --colors-text-link: var(--colors-primary-600);
  --colors-text-code: var(--colors-neutral-800);
  --colors-text-mark: var(--colors-warning-100);

  --colors-border-default: var(--colors-neutral-200);
  --colors-border-strong: var(--colors-neutral-300);
  --colors-border-hover: var(--colors-neutral-300);
  --colors-border-focus: var(--colors-primary-500);
  --colors-border-emphasis: var(--colors-primary-300);
  --colors-border-disabled: var(--colors-neutral-200);
  --colors-border-selected: var(--colors-primary-500);

  /* Interactive Colors */
  --colors-action-primary: var(--colors-primary-500);
  --colors-action-primaryHover: var(--colors-primary-600);
  --colors-action-primaryActive: var(--colors-primary-700);
  --colors-action-primaryDisabled: var(--colors-neutral-200);
  --colors-action-primaryFocus: var(--colors-primary-400);
  --colors-action-primarySubtle: var(--colors-primary-50);

  --colors-action-secondary: var(--colors-neutral-200);
  --colors-action-secondaryHover: var(--colors-neutral-300);
  --colors-action-secondaryActive: var(--colors-neutral-400);
  --colors-action-secondaryDisabled: var(--colors-neutral-100);
  --colors-action-secondaryFocus: var(--colors-neutral-300);
  --colors-action-secondarySubtle: var(--colors-neutral-50);

  /* Feedback Colors */
  --colors-feedback-info: var(--colors-primary-500);
  --colors-feedback-infoSubtle: var(--colors-primary-50);
  --colors-feedback-infoStrong: var(--colors-primary-700);
  --colors-feedback-infoMuted: var(--colors-primary-200);

  --colors-feedback-success: var(--colors-success-500);
  --colors-feedback-successSubtle: var(--colors-success-50);
  --colors-feedback-successStrong: var(--colors-success-700);
  --colors-feedback-successMuted: var(--colors-success-200);

  --colors-feedback-warning: var(--colors-warning-500);
  --colors-feedback-warningSubtle: var(--colors-warning-50);
  --colors-feedback-warningStrong: var(--colors-warning-700);
  --colors-feedback-warningMuted: var(--colors-warning-200);

  --colors-feedback-danger: var(--colors-danger-500);
  --colors-feedback-dangerSubtle: var(--colors-danger-50);
  --colors-feedback-dangerStrong: var(--colors-danger-700);
  --colors-feedback-dangerMuted: var(--colors-danger-200);

  /* State Colors */
  --colors-state-hover: var(--colors-neutral-100);
  --colors-state-selected: var(--colors-primary-50);
  --colors-state-focused: var(--colors-primary-100);
  --colors-state-pressed: var(--colors-neutral-200);
  --colors-state-disabled: var(--colors-neutral-100);
  --colors-state-loading: var(--colors-neutral-150);

  /* Typography */
  --typography-fonts-base: "Pretendard Variable", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  
  --typography-sizes-xs: 0.75rem;    /* 12px */
  --typography-sizes-sm: 0.875rem;   /* 14px */
  --typography-sizes-base: 1rem;     /* 16px */
  --typography-sizes-lg: 1.125rem;   /* 18px */
  --typography-sizes-xl: 1.25rem;    /* 20px */
  --typography-sizes-2xl: 1.5rem;    /* 24px */
  --typography-sizes-3xl: 1.875rem;  /* 30px */
  --typography-sizes-4xl: 2.25rem;   /* 36px */

  --typography-weights-light: 300;
  --typography-weights-normal: 400;
  --typography-weights-medium: 500;
  --typography-weights-semibold: 600;
  --typography-weights-bold: 700;

  --typography-line-heights-none: 1;
  --typography-line-heights-tight: 1.25;
  --typography-line-heights-snug: 1.375;
  --typography-line-heights-normal: 1.5;
  --typography-line-heights-relaxed: 1.625;
  --typography-line-heights-loose: 2;

  /* Radii */
  --radii-none: 0;
  --radii-sm: 0.125rem;  /* 2px */
  --radii-base: 0.25rem; /* 4px */
  --radii-md: 0.375rem;  /* 6px */
  --radii-lg: 0.5rem;    /* 8px */
  --radii-xl: 0.75rem;   /* 12px */
  --radii-2xl: 1rem;     /* 16px */
  --radii-full: 9999px;

  /* Transitions */
  --transitions-default: 150ms cubic-bezier(0.4, 0, 0.2, 1);
  --transitions-fast: 100ms cubic-bezier(0.4, 0, 0.2, 1);
  --transitions-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);

  /* Shadows */
  --shadows-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadows-base: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadows-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadows-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadows-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);

  /* Z-indices */
  --z-indices-hide: -1;
  --z-indices-base: 0;
  --z-indices-dropdown: 1000;
  --z-indices-sticky: 1100;
  --z-indices-modal: 1300;
  --z-indices-popover: 1400;
  --z-indices-tooltip: 1500;

  /* Spacing */
  --spacing-0: 0;
  --spacing-px: 1px;
  --spacing-0-5: 0.125rem;  /* 2px */
  --spacing-1: 0.25rem;     /* 4px */
  --spacing-1-5: 0.375rem;  /* 6px */
  --spacing-2: 0.5rem;      /* 8px */
  --spacing-2-5: 0.625rem;  /* 10px */
  --spacing-3: 0.75rem;     /* 12px */
  --spacing-3-5: 0.875rem;  /* 14px */
  --spacing-4: 1rem;        /* 16px */
  --spacing-5: 1.25rem;     /* 20px */
  --spacing-6: 1.5rem;      /* 24px */
  --spacing-7: 1.75rem;     /* 28px */
  --spacing-8: 2rem;        /* 32px */
  --spacing-9: 2.25rem;     /* 36px */
  --spacing-10: 2.5rem;     /* 40px */
  --spacing-11: 2.75rem;    /* 44px */
  --spacing-12: 3rem;       /* 48px */
  --spacing-14: 3.5rem;     /* 56px */
  --spacing-16: 4rem;       /* 64px */
  --spacing-20: 5rem;       /* 80px */
  --spacing-24: 6rem;       /* 96px */
  --spacing-28: 7rem;       /* 112px */
  --spacing-32: 8rem;       /* 128px */
  --spacing-36: 9rem;       /* 144px */
  --spacing-40: 10rem;      /* 160px */
  --spacing-44: 11rem;      /* 176px */
  --spacing-48: 12rem;      /* 192px */
  --spacing-52: 13rem;      /* 208px */
  --spacing-56: 14rem;      /* 224px */
  --spacing-60: 15rem;      /* 240px */
  --spacing-64: 16rem;      /* 256px */
  --spacing-72: 18rem;      /* 288px */
  --spacing-80: 20rem;      /* 320px */
  --spacing-96: 24rem;      /* 384px */

  /* Layout */
  --layout-max-width: 1280px;
  --layout-container-padding: var(--spacing-4);
  --layout-content-padding: var(--spacing-6);
  --layout-sidebar-width: var(--spacing-64);
  --layout-sidebar-collapsed-width: var(--spacing-20);
  --layout-topbar-height: var(--spacing-16);
  --layout-footer-height: var(--spacing-16);

  /* Grid */
  --grid-gap-x: var(--spacing-6);
  --grid-gap-y: var(--spacing-6);
  --grid-columns: 12;

  /* Layout System */
  --layout-spacing-page: var(--spacing-8);     /* 32px - 페이지 전체 여백 */
  --layout-spacing-section: var(--spacing-6);  /* 24px - 섹션 간 여백 */
  --layout-spacing-content: var(--spacing-4);  /* 16px - 컨텐츠 영역 여백 */

  /* Container Spacing - 컨테이너 내부 여백 */
  --container-spacing-lg: var(--spacing-6);    /* 24px - 큰 컨테이너(카드 등) */
  --container-spacing-md: var(--spacing-4);    /* 16px - 중간 컨테이너 */
  --container-spacing-sm: var(--spacing-3);    /* 12px - 작은 컨테이너 */

  /* Component Spacing - 컴포넌트 내부 요소 간 여백 */
  --component-spacing-lg: var(--spacing-4);    /* 16px - 큰 요소 간격 */
  --component-spacing-md: var(--spacing-3);    /* 12px - 중간 요소 간격 */
  --component-spacing-sm: var(--spacing-2);    /* 8px - 작은 요소 간격 */

  /* Element Spacing - 텍스트, 아이콘 등 작은 요소 간 여백 */
  --element-spacing-lg: var(--spacing-3);      /* 12px - 큰 간격 */
  --element-spacing-md: var(--spacing-2);      /* 8px - 중간 간격 */
  --element-spacing-sm: var(--spacing-1);      /* 4px - 작은 간격 */

  /* Grid Spacing */
  --grid-spacing-lg: var(--spacing-6);         /* 24px - 큰 그리드 갭 */
  --grid-spacing-md: var(--spacing-4);         /* 16px - 중간 그리드 갭 */
  --grid-spacing-sm: var(--spacing-3);         /* 12px - 작은 그리드 갭 */
}

/* 다크 테마 */
[data-theme='dark'] {
  --colors-background-primary: var(--colors-neutral-900);
  --colors-background-secondary: var(--colors-neutral-800);
  --colors-background-tertiary: var(--colors-neutral-700);

  --colors-text-primary: var(--colors-neutral-50);
  --colors-text-secondary: var(--colors-neutral-300);
  --colors-text-tertiary: var(--colors-neutral-400);
  --colors-text-disabled: var(--colors-neutral-600);

  --colors-border-default: var(--colors-neutral-700);
  --colors-border-hover: var(--colors-neutral-600);

  --colors-action-secondary: var(--colors-neutral-700);
  --colors-action-secondaryHover: var(--colors-neutral-600);
  --colors-action-secondaryActive: var(--colors-neutral-500);
}

/* 기본 스타일 */
body {
  font-family: var(--typography-fonts-base);
  font-size: var(--typography-sizes-base);
  line-height: var(--typography-line-heights-normal);
  background-color: var(--colors-background-primary);
  color: var(--colors-text-primary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 레이아웃 유틸리티 */
.container {
  width: 100%;
  max-width: var(--layout-max-width);
  margin-left: auto;
  margin-right: auto;
  padding-left: var(--layout-container-padding);
  padding-right: var(--layout-container-padding);
}

.content-area {
  padding: var(--layout-content-padding);
}'use client'
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import LoginForm from '@/components/auth/LoginForm';
import Card from '@/components/common/Card';
import { useAuth } from '@/hooks/useAuth';
import LoadingSpinner from '@/components/common/LoadingSpinner';

export default function LoginPage() {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && user) {
      // 이미 로그인된 상태면 대시보드로 리다이렉트
      router.push('/dashboard');
    }
  }, [user, loading, router]);

  // 로딩 중이거나 리다이렉트 중일 때
  if (loading || user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <LoadingSpinner size="lg" text="로딩 중..." />
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center">
      <Card className="w-full max-w-md">
        <h1 className="text-2xl font-bold mb-6 text-center">THC Core 로그인</h1>
        <LoginForm />
      </Card>
    </div>
  );
}import { redirect } from 'next/navigation';

export default function Home() {
  redirect('/login');
}'use client'

import { QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { queryClient } from '@/lib/react-query'

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}'use client'
import { useState } from 'react'
import { useAuth } from '@/hooks/useAuth'
import { FirebaseError } from 'firebase/app'
import { getFirebaseErrorMessage } from '@/utils/firebase-errors'
import Button from '@/components/common/Button'
import Input from '@/components/common/Input'

interface FormData {
  email: string
  password: string
}

interface ValidationErrors {
  email?: string
  password?: string
  submit?: string
}

export default function LoginForm() {
  const [formData, setFormData] = useState<FormData>({ email: '', password: '' })
  const [errors, setErrors] = useState<ValidationErrors>({})
  const [isLoading, setIsLoading] = useState(false)
  const { login } = useAuth()

  const validateEmail = (email: string): string | undefined => {
    if (!email) return undefined
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return '유효한 이메일 주소를 입력해주세요'
    }
    return undefined
  }

  const validatePassword = (password: string): string | undefined => {
    if (!password) return undefined
    if (password.length < 6) {
      return '비밀번호는 최소 6자 이상이어야 합니다'
    }
    return undefined
  }

  const validateForm = (): boolean => {
    const newErrors: ValidationErrors = {
      email: validateEmail(formData.email),
      password: validatePassword(formData.password),
    }
    setErrors(prev => ({ ...prev, ...newErrors }))
    return !Object.values(newErrors).some(Boolean)
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({ ...prev, [name]: value }))
    setErrors(prev => ({
      ...prev,
      submit: undefined,
      [name]: name === 'email' ? validateEmail(value) : validatePassword(value)
    }))
  }

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name } = e.target
    setErrors(prev => ({
      ...prev,
      [name]: name === 'email' 
        ? validateEmail(formData.email) 
        : validatePassword(formData.password)
    }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!validateForm()) return
    
    setIsLoading(true)
    try {
      await login(formData.email, formData.password)
    } catch (error) {
      const message = error instanceof FirebaseError 
        ? getFirebaseErrorMessage(error)
        : '알 수 없는 오류가 발생했습니다'
      setErrors(prev => ({ ...prev, submit: message }))
    } finally {
      setIsLoading(false)
    }
  }

  const isSubmitDisabled = isLoading || 
    !formData.email || 
    !formData.password || 
    Boolean(errors.email) || 
    Boolean(errors.password)

  return (
    <form onSubmit={handleSubmit} className="space-y-4" noValidate>
      <Input
        id="email"
        name="email"
        type="email"
        label="이메일"
        value={formData.email}
        onChange={handleChange}
        onBlur={handleBlur}
        disabled={isLoading}
        error={errors.email}
        placeholder="이메일 주소를 입력하세요"
        autoComplete="email"
        required
      />

      <Input
        id="password"
        name="password"
        type="password"
        label="비밀번호"
        value={formData.password}
        onChange={handleChange}
        onBlur={handleBlur}
        disabled={isLoading}
        error={errors.password}
        placeholder="비밀번호를 입력하세요"
        autoComplete="current-password"
        required
      />

      {errors.submit && (
        <div className="text-[var(--colors-danger-500)] text-sm" role="alert">
          {errors.submit}
        </div>
      )}

      <Button
        type="submit"
        disabled={isSubmitDisabled}
        loading={isLoading}
        className="w-full"
      >
        로그인
      </Button>
    </form>
  )
}'use client'
import { useState } from 'react';

interface AccordionItemProps {
  title: string;
  content: string;
}

const AccordionItem = ({ title, content }: AccordionItemProps) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="border-b border-gray-200">
      <button
        className="w-full px-4 py-3 text-left hover:bg-blue-50 focus:outline-none flex justify-between items-center"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span className="font-medium">{title}</span>
        <svg
          className={`w-5 h-5 transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`}
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      <div 
        className={`
          px-4 overflow-hidden 
          transition-all duration-300 ease-in-out 
          ${isOpen ? 'max-h-40 py-3 opacity-100' : 'max-h-0 opacity-0'}
        `}
      >
        {content}
      </div>
    </div>
  );
};

export default function Accordion() {
  const items = [
    {
      title: "섹션 1",
      content: "여기는 첫 번째 섹션의 내용입니다. 원하는 내용을 넣어주세요."
    },
    {
      title: "섹션 2",
      content: "두 번째 섹션입니다. 다른 내용을 넣어볼 수 있습니다."
    },
    {
      title: "섹션 3",
      content: "세 번째 섹션의 내용입니다. 얼마든지 섹션을 추가할 수 있어요."
    }
  ];

  return (
    <div className="w-full max-w-md mx-auto mt-4 rounded-lg border border-gray-200 divide-y">
      {items.map((item, index) => (
        <AccordionItem key={index} {...item} />
      ))}
    </div>
  );
}import { cn } from '@/utils/cn'
import type { HTMLAttributes } from 'react'

export type CardVariant = 'elevated' | 'outlined'
export type CardPadding = 'none' | 'sm' | 'md' | 'lg'

interface CardProps extends HTMLAttributes<HTMLDivElement> {
  variant?: CardVariant
  padding?: CardPadding
}

export default function Card({ 
  variant = 'elevated',
  padding = 'md',
  className,
  children,
  ...props
}: CardProps) {
  return (
    <div
      className={cn(
        'rounded-[var(--radii-lg)]',
        // Variants
        variant === 'elevated' && 'bg-[var(--colors-background-primary)] shadow-[var(--shadows-md)] border border-[var(--colors-border-default)]',
        variant === 'outlined' && 'border border-[var(--colors-border-default)]',
        // Padding
        padding === 'none' && 'p-0',
        padding === 'sm' && 'p-[var(--container-spacing-sm)]',
        padding === 'md' && 'p-[var(--container-spacing-md)]',
        padding === 'lg' && 'p-[var(--container-spacing-lg)]',
        className
      )}
      {...props}
    >
      {children}
    </div>
  )
}interface LoadingSpinnerProps {
    size?: 'sm' | 'md' | 'lg'
    text?: string
    className?: string
  }
  
  export default function LoadingSpinner({ size = 'md', text, className = '' }: LoadingSpinnerProps) {
    const sizeClasses = {
      sm: 'h-4 w-4',
      md: 'h-6 w-6',
      lg: 'h-8 w-8'
    }
  
    return (
      <div className={`flex items-center justify-center gap-3 ${className}`}>
        <svg 
          className={`animate-spin ${sizeClasses[size]} text-blue-500`}
          xmlns="http://www.w3.org/2000/svg" 
          fill="none" 
          viewBox="0 0 24 24"
        >
          <circle 
            className="opacity-25" 
            cx="12" 
            cy="12" 
            r="10" 
            stroke="currentColor" 
            strokeWidth="4"
          />
          <path 
            className="opacity-75" 
            fill="currentColor" 
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
        {text && <span className="text-gray-600">{text}</span>}
      </div>
    )
  }'use client'

import { ArrowPathIcon } from '@heroicons/react/24/outline'
import { useEffect, useState } from 'react'

interface RefreshButtonProps {
  onClick: () => Promise<void>
  isLoading: boolean
  lastUpdated?: number
}

const RefreshButton = ({ onClick, isLoading, lastUpdated }: RefreshButtonProps) => {
  const [timeAgo, setTimeAgo] = useState<string>('')

  useEffect(() => {
    const updateTimeAgo = () => {
      if (!lastUpdated) return

      const seconds = Math.floor((new Date().getTime() - lastUpdated) / 1000)
      
      if (seconds < 60) {
        setTimeAgo(`${seconds}초 전`)
        return
      }
      
      const minutes = Math.floor(seconds / 60)
      if (minutes < 60) {
        setTimeAgo(`${minutes}분 전`)
        return
      }
      
      const hours = Math.floor(minutes / 60)
      if (hours < 24) {
        setTimeAgo(`${hours}시간 전`)
        return
      }
      
      setTimeAgo(new Date(lastUpdated).toLocaleDateString())
    }

    updateTimeAgo()
    const timer = setInterval(updateTimeAgo, 1000) // 1초마다 업데이트

    return () => clearInterval(timer)
  }, [lastUpdated])

  return (
    <div className="flex items-center gap-4">
      {timeAgo && (
        <span className="text-sm text-gray-500">
          마지막 업데이트: {timeAgo}
        </span>
      )}
      
      <button
        onClick={onClick}
        disabled={isLoading}
        className="flex items-center gap-2 px-3 py-1.5 text-sm text-gray-600 hover:text-gray-900 disabled:opacity-50"
        title="데이터 새로고침"
      >
        <ArrowPathIcon 
          className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} 
        />
        <span>새로고침</span>
      </button>
    </div>
  )
}

export default RefreshButton'use client'
import { BarChart as RechartsBarChart, Bar } from 'recharts';
import BaseChart, { chartCommonProps } from './BaseChart';
import { CONFIG } from '@/constants/config';
import type { ChartData } from '@/hooks/useChartData';

interface BarChartProps {
  data: ChartData[];
  isLoading?: boolean;
}

export default function BarChart({ data, isLoading = false }: BarChartProps) {
  return (
    <BaseChart isLoading={isLoading}>
      <RechartsBarChart data={data} {...chartCommonProps}>
        {chartCommonProps.children}
        <Bar dataKey="sales" fill={CONFIG.CHART.COLORS.SALES} />
        <Bar dataKey="revenue" fill={CONFIG.CHART.COLORS.REVENUE} />
      </RechartsBarChart>
    </BaseChart>
  );
}'use client'
import { ReactElement } from 'react';
import { ResponsiveContainer, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import { CONFIG } from '@/constants/config';
import type { ChartData } from '@/hooks/useChartData';

interface BaseChartProps {
  data: ChartData[];
  isLoading?: boolean;
  children: ReactElement;
}

export default function BaseChart({ isLoading = false, children }: Omit<BaseChartProps, 'data'>) {
  if (isLoading) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" />
      </div>
    );
  }

  return (
    <ResponsiveContainer width="100%" height="100%">
      {children}
    </ResponsiveContainer>
  );
}

// 공통으로 사용되는 차트 설정들
export const chartCommonProps = {
  margin: CONFIG.CHART.MARGIN,
  children: (
    <>
      <CartesianGrid strokeDasharray="3 3" stroke={CONFIG.CHART.COLORS.GRID} />
      <XAxis dataKey="name" stroke={CONFIG.CHART.COLORS.AXIS} />
      <YAxis stroke={CONFIG.CHART.COLORS.AXIS} />
      <Tooltip 
        contentStyle={{ backgroundColor: '#1F2937', border: 'none' }}
        labelStyle={{ color: CONFIG.CHART.COLORS.AXIS }}
      />
      <Legend 
        verticalAlign="top"
        height={36}
        wrapperStyle={{
          paddingBottom: '10px',
          marginTop: '-10px'
        }}
      />
    </>
  ),
};'use client'
import { useAuth } from '@/hooks/useAuth';
import Card from '@/components/common/Card';
import TodoBoard from '@/components/dashboard/TodoBoard';

export default function DashboardContent() {
  const { user, loading } = useAuth();

  if (loading || !user) return null;

  return (
    <div className="space-y-6">
      <Card className="p-6">
        <h2 className="text-xl font-bold mb-6">할 일 관리</h2>
        <TodoBoard />
      </Card>
    </div>
  );
}'use client'
import { LineChart as RechartsLineChart, Line } from 'recharts';
import BaseChart, { chartCommonProps } from './BaseChart';
import { CONFIG } from '@/constants/config';
import type { ChartData } from '@/hooks/useChartData';

interface LineChartProps {
  data: ChartData[];
  isLoading?: boolean;
}

export default function LineChart({ data, isLoading = false }: LineChartProps) {
  return (
    <BaseChart isLoading={isLoading}>
      <RechartsLineChart data={data} {...chartCommonProps}>
        {chartCommonProps.children}
        <Line 
          type="monotone" 
          dataKey="sales" 
          stroke={CONFIG.CHART.COLORS.SALES}
          strokeWidth={2}
          dot={{ fill: CONFIG.CHART.COLORS.SALES }}
          activeDot={{ r: 6 }}
        />
        <Line 
          type="monotone" 
          dataKey="revenue" 
          stroke={CONFIG.CHART.COLORS.REVENUE}
          strokeWidth={2}
          dot={{ fill: CONFIG.CHART.COLORS.REVENUE }}
          activeDot={{ r: 6 }}
        />
      </RechartsLineChart>
    </BaseChart>
  );
}'use client'

import { useForm } from 'react-hook-form'
import { useFirestoreCollection } from '@/hooks/firestore/useFirestoreCollection'
import type { Site, Vendor, PaymentRequestFormData } from '@/types/payment'
import Button from '@/components/common/Button'
import Input from '@/components/common/Input'
import RefreshButton from '@/components/common/RefreshButton'

export default function PaymentRequestForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<PaymentRequestFormData>()

  const { 
    data: sites, 
    refetch: refetchSites,
    isFetching: isFetchingSites,
    dataUpdatedAt: sitesUpdatedAt
  } = useFirestoreCollection<Site>('sites')
  
  const { 
    data: vendors, 
    refetch: refetchVendors,
    isFetching: isFetchingVendors,
    dataUpdatedAt: vendorsUpdatedAt
  } = useFirestoreCollection<Vendor>('vendors')

  const handleRefresh = async () => {
    await Promise.all([
      refetchSites(),
      refetchVendors()
    ])
  }

  const onSubmit = async (data: PaymentRequestFormData) => {
    try {
      console.log(data)
      // TODO: 비용 청구 로직 구현
    } catch (error) {
      console.error(error)
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-[var(--layout-spacing-content)]">
      <div className="flex justify-end">
        <RefreshButton
          onClick={handleRefresh}
          isLoading={isFetchingSites || isFetchingVendors}
          lastUpdated={Math.max(sitesUpdatedAt || 0, vendorsUpdatedAt || 0)}
        />
      </div>

      {sites && vendors && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-[var(--grid-spacing-md)]">
            <div className="space-y-[var(--component-spacing-sm)]">
              <label htmlFor="siteId" className="block text-sm font-medium text-[var(--colors-text-secondary)]">
                현장
              </label>
              <select
                id="siteId"
                {...register('siteId', { required: '현장을 선택해주세요' })}
                className="block w-full rounded-[var(--radii-base)] border border-[var(--colors-border-default)] bg-[var(--colors-background-primary)] px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-[var(--colors-text-primary)] shadow-sm focus:border-[var(--colors-border-focus)] focus:outline-none focus:ring-1 focus:ring-[var(--colors-border-focus)]"
              >
                <option value="">현장을 선택하세요</option>
                {sites.map((site: Site) => (
                  <option key={site.id} value={site.id}>
                    {site.name}
                  </option>
                ))}
              </select>
              {errors.siteId && (
                <p className="text-sm text-[var(--colors-danger-500)]">{errors.siteId.message}</p>
              )}
            </div>

            <div className="space-y-[var(--component-spacing-sm)]">
              <label htmlFor="vendorId" className="block text-sm font-medium text-[var(--colors-text-secondary)]">
                거래처
              </label>
              <select
                id="vendorId"
                {...register('vendorId', { required: '거래처를 선택해주세요' })}
                className="block w-full rounded-[var(--radii-base)] border border-[var(--colors-border-default)] bg-[var(--colors-background-primary)] px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-[var(--colors-text-primary)] shadow-sm focus:border-[var(--colors-border-focus)] focus:outline-none focus:ring-1 focus:ring-[var(--colors-border-focus)]"
              >
                <option value="">거래처를 선택하세요</option>
                {vendors.map((vendor: Vendor) => (
                  <option key={vendor.id} value={vendor.id}>
                    {vendor.name}
                  </option>
                ))}
              </select>
              {errors.vendorId && (
                <p className="text-sm text-[var(--colors-danger-500)]">{errors.vendorId.message}</p>
              )}
            </div>
          </div>

          <Input
            id="title"
            label="제목"
            error={errors.title?.message}
            placeholder="청구 제목을 입력하세요"
            {...register('title', { required: '제목을 입력해주세요' })}
          />

          <Input
            id="amount"
            type="number"
            label="금액"
            error={errors.amount?.message}
            placeholder="금액을 입력하세요"
            {...register('amount', { 
              required: '금액을 입력해주세요',
              min: { value: 1000, message: '최소 금액은 1,000원입니다' }
            })}
          />

          <div className="space-y-[var(--component-spacing-sm)]">
            <label htmlFor="description" className="block text-sm font-medium text-[var(--colors-text-secondary)]">
              상세 내용
            </label>
            <textarea
              id="description"
              {...register('description', { required: '상세 내용을 입력해주세요' })}
              className="block w-full rounded-[var(--radii-base)] border border-[var(--colors-border-default)] bg-[var(--colors-background-primary)] px-[var(--container-spacing-md)] py-[var(--component-spacing-sm)] text-[var(--colors-text-primary)] shadow-sm focus:border-[var(--colors-border-focus)] focus:outline-none focus:ring-1 focus:ring-[var(--colors-border-focus)]"
              rows={4}
              placeholder="청구 상세 내용을 입력하세요"
            />
            {errors.description && (
              <p className="text-sm text-[var(--colors-danger-500)]">{errors.description.message}</p>
            )}
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-[var(--grid-spacing-md)]">
            <Input
              id="requestDate"
              type="date"
              label="청구일"
              error={errors.requestDate?.message}
              {...register('requestDate', { required: '청구일을 선택해주세요' })}
            />

            <Input
              id="dueDate"
              type="date"
              label="만기일"
              error={errors.dueDate?.message}
              {...register('dueDate', { required: '만기일을 선택해주세요' })}
            />
          </div>

          <div className="flex justify-end gap-[var(--element-spacing-md)]">
            <Button
              type="submit"
              variant="primary"
              disabled={isSubmitting}
            >
              {isSubmitting ? '처리 중...' : '청구하기'}
            </Button>
          </div>
        </>
      )}
    </form>
  )
}'use client'

import { useState } from 'react'
import Avatar from 'boring-avatars'
import { useUpdateDoc } from '@/hooks/firestore/useUpdateDoc'

// variant 타입 정의
type AvatarVariant = 'beam' | 'marble' | 'pixel' | 'sunset' | 'ring'

// 색상 팔레트 타입 정의
type ColorPalette = {
  [key: string]: string[]
}

const COLOR_PALETTES: ColorPalette = {
  classic: ["#01BAEF", "#0CBABA", "#380036", "#1B1B1B", "#FFFFFF"],
  arcade: ["#FF2E63", "#08D9D6", "#252A34", "#EAEAEA", "#FF2E63"],
  jungle: ["#95F9E3", "#49BEB7", "#085F63", "#FF5959", "#FACF5A"],
  galaxy: ["#7400B8", "#5E60CE", "#4EA8DE", "#56CFE1", "#72EFDD"],
  sunset: ["#FF7B00", "#FF8800", "#FF9500", "#FFA200", "#FFAA00"],
  neon: ["#FF0000", "#FF00FF", "#00FFFF", "#00FF00", "#FFFF00"],
  candy: ["#FF449F", "#FF7BA9", "#FFA1B8", "#FFB5C2", "#FFD6DE"],
  ocean: ["#05445E", "#189AB4", "#75E6DA", "#D4F1F4", "#05445E"]
}

interface AvatarSelectorProps {
  isOpen: boolean
  onClose: () => void
  onSelect: (config: {
    name: string
    variant: 'beam' | 'marble' | 'pixel' | 'sunset' | 'ring'
    colors: string[]
  }) => void
  userId: string
}

type AvatarConfig = {
  name: string;
  variant: 'beam' | 'marble' | 'pixel' | 'sunset' | 'ring';
  colors: string[];
}

export default function AvatarSelector({ isOpen, onClose, onSelect, userId }: AvatarSelectorProps) {
  const { updateDocument, isLoading } = useUpdateDoc<{ avatarConfig: AvatarConfig }>('users')
  const [config, setConfig] = useState<AvatarConfig>({
    name: Date.now().toString(),
    variant: 'beam',
    colors: ['#92A1C6', '#146A7C', '#F0AB3D', '#C271B4', '#C20D90']
  })

  const handleSelect = async () => {
    try {
      await updateDocument(userId, { avatarConfig: config })
      onSelect(config)
      onClose()
    } catch (error) {
      console.error('Failed to update avatar:', error)
    }
  }

  const generateNewName = () => {
    setConfig(prev => ({
      ...prev,
      name: Date.now().toString()
    }))
  }

  const generateRandomColor = () => {
    return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')
  }

  const generateRandomColors = () => {
    return Array.from({ length: 5 }, () => generateRandomColor())
  }

  const generateNewColors = () => {
    setConfig(prev => ({
      ...prev,
      colors: generateRandomColors()
    }))
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4">
        <h2 className="text-xl font-semibold mb-6">아바타 스타일 선택</h2>

        <div className="flex gap-8">
          {/* 큰 미리보기 */}
          <div className="flex flex-col items-center gap-4">
            <Avatar {...config} size={120} />
            <div className="flex gap-2 whitespace-nowrap">
              <button
                onClick={generateNewName}
                className="px-4 py-2 bg-blue-100 hover:bg-blue-200 rounded text-sm"
              >
                패턴 섞기
              </button>
              <button
                onClick={generateNewColors}
                className="px-4 py-2 bg-purple-100 hover:bg-purple-200 rounded text-sm"
              >
                색상 섞기
              </button>
            </div>
          </div>

          <div className="flex-grow space-y-6">
            {/* 스타일 선택 */}
            <div>
              <h3 className="text-sm font-medium mb-3">스타일</h3>
              <div className="grid grid-cols-5 gap-4">
                {['beam', 'marble', 'pixel', 'sunset', 'ring'].map((variant) => (
                  <button
                    key={variant}
                    onClick={() => setConfig(prev => ({ ...prev, variant: variant as AvatarVariant }))}
                    className={`p-4 rounded flex flex-col items-center gap-2 ${
                      config.variant === variant ? 'bg-blue-100' : 'bg-gray-50 hover:bg-gray-100'
                    }`}
                  >
                    <Avatar
                      name={config.name}
                      variant={variant as AvatarVariant}
                      colors={config.colors}
                      size={40}
                    />
                    <span className="text-sm capitalize">{variant}</span>
                  </button>
                ))}
              </div>
            </div>

            {/* 색상 팔레트 */}
            <div>
              <h3 className="text-sm font-medium mb-3">컬러 팔레트</h3>
              <div className="grid grid-cols-2 gap-3">
                {Object.entries(COLOR_PALETTES).map(([name, colors]) => (
                  <button
                    key={name}
                    onClick={() => setConfig(prev => ({ ...prev, colors }))}
                    className={`p-3 rounded flex items-center justify-between ${
                      config.colors === colors ? 'bg-blue-100' : 'bg-gray-50 hover:bg-gray-100'
                    }`}
                  >
                    <span className="text-sm">
                      {name === 'classic' && '클래식'}
                      {name === 'arcade' && '아케이드'}
                      {name === 'jungle' && '정글'}
                      {name === 'galaxy' && '갤럭시'}
                      {name === 'sunset' && '선셋'}
                      {name === 'neon' && '네온'}
                      {name === 'candy' && '캔디'}
                      {name === 'ocean' && '오션'}
                    </span>
                    <div className="flex gap-1">
                      {colors.map((color, i) => (
                        <div
                          key={i}
                          className="w-4 h-4 rounded-full"
                          style={{ backgroundColor: color }}
                        />
                      ))}
                    </div>
                  </button>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* 하단 버튼 */}
        <div className="mt-6 flex justify-end gap-2">
          <button
            onClick={handleSelect}
            disabled={isLoading}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          >
            {isLoading ? '저장 중...' : '선택'}
          </button>
          <button
            onClick={onClose}
            disabled={isLoading}
            className="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50"
          >
            취소
          </button>
        </div>
      </div>
    </div>
  )
}export const CONFIG = {
    CHART: {
      MARGIN: { top: 20, right: 30, left: 20, bottom: 25 },
      COLORS: {
        SALES: '#3B82F6',
        REVENUE: '#10B981',
        GRID: '#374151',
        AXIS: '#9CA3AF',
      },
    },
    CARD: {
      DEFAULT_HEIGHT: {
        SMALL: 300,
        MEDIUM: 400,
      },
    },
  } as const;export const MESSAGES = {
    KOREAN: {
      CASH_FLOW: {
        TITLE: '전체 현금 흐름',
        CURRENT_BALANCE: '현재 잔액',
        MONTHLY_REVENUE: '월간 수입',
        MONTHLY_EXPENSES: '월간 지출',
      },
      ALERTS: {
        TITLE: '긴급 조치 필요',
        RESTAURANT_INVENTORY: '레스토랑 식자재 재고 부족',
        BUILDING_MAINTENANCE: '건물 A동 유지보수 예정',
        CONSTRUCTION_MATERIALS: '건설현장 자재 발주 필요',
      },
      BUSINESS_STATUS: {
        CONSTRUCTION: {
          TITLE: '건설업 현황',
          ACTIVE_PROJECTS: '진행 중인 프로젝트',
          PROGRESS: '전체 공정률',
          GOAL_ACHIEVEMENT: '이번 달 목표 달성률',
        },
        RESTAURANT: {
          TITLE: '레스토랑 현황',
          RESERVATIONS: '오늘의 예약',
          OCCUPANCY: '현재 테이블 점유율',
          GOAL_ACHIEVEMENT: '일일 매출 목표 달성률',
        },
        BUILDING: {
          TITLE: '빌딩 관리 현황',
          OCCUPANCY_RATE: '임대율',
          FEE_COLLECTION: '이번 달 관리비 수금률',
          PENDING_ISSUES: '보류 중인 민원',
        },
      },
    },
    ENGLISH: {
      CASH_FLOW: {
        TITLE: 'Total Cash Flow',
        CURRENT_BALANCE: 'Current Balance',
        MONTHLY_REVENUE: 'Monthly Revenue',
        MONTHLY_EXPENSES: 'Monthly Expenses',
      },
      // ... 영문 메시지도 동일한 구조로 작성
    },
  } as const;import { useQuery } from '@tanstack/react-query'
import { collection, getDocs } from 'firebase/firestore'
import { db } from '@/lib/firebase'

export function useFirestoreCollection<T>(collectionName: string) {
  return useQuery({
    queryKey: ['collection', collectionName],
    queryFn: async () => {
      console.log(`📥 ${collectionName} 컬렉션 요청...`)
      const snapshot = await getDocs(collection(db, collectionName))
      const items = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as T[]
      console.log(`✅ ${collectionName} 컬렉션 수신:`, items.length, '개')
      return items
    }
  })
} import { useQuery } from '@tanstack/react-query'
import { Query, onSnapshot } from 'firebase/firestore'

// 순수하게 onSnapshot 리스너만 담당하는 훅
export function useFirestoreSnapshot(key: string[], query: Query) {
  return useQuery({
    queryKey: key,
    queryFn: () => new Promise((resolve, reject) => {
      const unsubscribe = onSnapshot(
        query,
        (snapshot) => {
          const data = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }))
          resolve(data)
        },
        reject
      )
      return () => unsubscribe()
    }),
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    refetchInterval: false,
  })
}import { doc, updateDoc, DocumentData } from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { useState } from 'react'

export function useUpdateDoc<T extends DocumentData>(collectionName: string) {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const updateDocument = async (id: string, data: Partial<T>) => {
    setIsLoading(true)
    setError(null)
    try {
      const docRef = doc(db, collectionName, id)
      await updateDoc(docRef, data as DocumentData)
    } catch (err) {
      setError(err as Error)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  return {
    updateDocument,
    isLoading,
    error
  }
}'use client'
import { useState, useEffect } from 'react';
import { 
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  User
} from 'firebase/auth';
import { doc, updateDoc, serverTimestamp, getDoc, setDoc } from 'firebase/firestore';
import { auth, db } from '@/lib/firebase';
import { useRouter } from 'next/navigation';

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user);
      setLoading(false);
    });

    return () => unsubscribe();
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      
      // Firestore users 컬렉션 업데이트
      const userRef = doc(db, 'users', userCredential.user.uid);
      const userDoc = await getDoc(userRef);

      if (!userDoc.exists()) {
        // 사용자 문서가 없으면 생성
        await setDoc(userRef, {
          uid: userCredential.user.uid,
          email: userCredential.user.email,
          role: 'user',  // 기본 역할
          status: 'active',
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          lastLoginAt: serverTimestamp(),
          createdBy: userCredential.user.uid,
          updatedBy: userCredential.user.uid
        });
      } else {
        // 문서가 있으면 업데이트만
        await updateDoc(userRef, {
          lastLoginAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          updatedBy: userCredential.user.uid
        });
      }

      router.push('/dashboard');
      return userCredential.user;
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const logout = async () => {
    try {
      await signOut(auth);
      router.push('/');
    } catch (error) {
      console.error('Logout error:', error);
      throw error;
    }
  };

  return {
    user,
    loading,
    login,
    logout
  };
}import { useState } from 'react';

export interface ChartData {
  name: string;
  sales: number;
  revenue: number;
}

export function useChartData() {
  const [data] = useState<ChartData[]>([
    { name: 'Jan', sales: 400, revenue: 1600 },
    { name: 'Feb', sales: 300, revenue: 2500 },
    { name: 'Mar', sales: 600, revenue: 800 },
    { name: 'Apr', sales: 800, revenue: 1000 },
    { name: 'May', sales: 500, revenue: 700 },
    { name: 'Jun', sales: 700, revenue: 900 },
  ]);

  return { data };
}'use client'

import { useAuth } from './useAuth'
import { doc, getDoc } from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { useQuery } from '@tanstack/react-query'

type UserRole = 'super_admin' | 'admin' | 'user'

export function useUserRole() {
  const { user } = useAuth()

  const { data: role, isLoading } = useQuery({
    queryKey: ['userRole', user?.uid],
    queryFn: async (): Promise<UserRole> => {
      if (!user?.uid) return 'user'
      
      const userDoc = await getDoc(doc(db, 'users', user.uid))
      return userDoc.exists() ? (userDoc.data().role as UserRole) : 'user'
    },
    enabled: !!user,
  })
  
  return {
    role: role || 'user',
    loading: isLoading,
    isSuperAdmin: role === 'super_admin',
    isAdmin: role === 'admin',
    isUser: role === 'user',
  }
}'use client';

import { initializeApp, getApps } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// 개발 환경에서만 누락된 변수 체크
if (process.env.NODE_ENV === 'development') {
  const missingVars = Object.entries(firebaseConfig)
    .filter(([, value]) => !value)
    .map(([key]) => key);

  if (missingVars.length > 0) {
    console.error('Missing required environment variables:', missingVars);
  }
}

export const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];
export const auth = getAuth(app);
export const db = getFirestore(app);
import { Firestore } from 'firebase/firestore'
import { db } from '@/lib/firebase'

export const firestore: Firestore = dbimport { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,    // 5분
      gcTime: 10 * 60 * 1000,      // 10분
      refetchOnWindowFocus: false,  // 윈도우 포커스시 재요청 방지
      refetchOnMount: false,        // 컴포넌트 마운트시 재요청 방지
      retry: 1,                     // 실패시 1번만 재시도
    },
  },
})// 1) 색상 팔레트 정의
const colors = {
  ebony: {
    50:  '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94a3b8',
    500: '#64748b',
    600: '#475569',
    700: '#334155',
    800: '#1e293b',
    900: '#0f172a',
  },
  redwood: {
    50:  '#fdf8f6',
    100: '#f2e8e5',
    200: '#eaddd7',
    300: '#e0cec7',
    400: '#d2bab0',
    500: '#bfa094',
    600: '#a18072',
    700: '#977669',
    800: '#846358',
    900: '#43302b',
  },
  twilight: {
    50:  '#f5f3ff',
    100: '#ede9fe',
    200: '#ddd6fe',
    300: '#c4b5fd',
    400: '#a78bfa',
    500: '#8b5cf6',
    600: '#7c3aed',
    700: '#6d28d9',
    800: '#5b21b6',
    900: '#4c1d95',
  },
  storm: {
    50:  '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94a3b8',
    500: '#64748b',
    600: '#475569',
    700: '#334155',
    800: '#1e293b',
    900: '#0f172a',
  },
  coffee: {
    50:  '#fdf8f6',
    100: '#e8d6d0',
    200: '#d3b8ae',
    300: '#be9b8e',
    400: '#a97e6e',
    500: '#936251',
    600: '#7d4735',
    700: '#672d1e',
    800: '#50160c',
    900: '#3a0400',
  },
} as const;

// 2) 다크 테마 생성 함수
function createDarkTheme(name: string, palette: (typeof colors)[keyof typeof colors]) {
  return {
    name,
    colors: {
      '--background': palette[900],
      '--foreground': palette[50],
      '--cardBackground': palette[800],
      '--borderColor': palette[700],
    },
  } as const;
}

// 3) 테마 정의
export const themes = {
  ebony: createDarkTheme('에보니', colors.ebony),
  redwood: createDarkTheme('레드우드', colors.redwood),
  twilight: createDarkTheme('트와일라이트', colors.twilight),
  storm: createDarkTheme('스톰', colors.storm),
  coffee: createDarkTheme('커피', colors.coffee),
} as const;

export type ThemeType = keyof typeof themes;import * as dotenv from 'dotenv'
import path from 'path'

// .env.local 파일 로드
dotenv.config({ path: path.resolve(process.cwd(), '.env.local') })

import { db } from '@/lib/firebase'
import { addDoc, collection } from 'firebase/firestore'

// 현장 데이터
const sites = [
  {
    code: 'HQ',
    name: '본사',
    status: 'ACTIVE',
    startDate: new Date('2020-01-01'),
  },
  {
    code: 'SITE001',
    name: '서울 프로젝트',
    status: 'ACTIVE',
    startDate: new Date('2024-01-01'),
  },
  {
    code: 'SITE002',
    name: '부산 프로젝트',
    status: 'ACTIVE',
    startDate: new Date('2024-02-01'),
  },
]

// 거래처 데이터
const vendors = [
  {
    id: 'VENDOR001',
    businessNumber: '123-45-67890',
    name: '(주)가나건설',
    status: 'ACTIVE',
  },
  {
    id: 'VENDOR002',
    businessNumber: '234-56-78901',
    name: '대한건설(주)',
    status: 'ACTIVE',
  },
  {
    id: 'VENDOR003',
    businessNumber: '345-67-89012',
    name: '한국자재(주)',
    status: 'ACTIVE',
  },
]

// 데이터 추가 함수
async function seedData() {
  try {
    // 현장 데이터 추가
    const sitesRef = collection(db, 'sites')
    for (const site of sites) {
      await addDoc(sitesRef, site)
    }
    console.log('현장 데이터 추가 완료')

    // 거래처 데이터 추가
    const vendorsRef = collection(db, 'vendors')
    for (const vendor of vendors) {
      await addDoc(vendorsRef, vendor)
    }
    console.log('거래처 데이터 추가 완료')

  } catch (error) {
    console.error('데이터 추가 중 오류 발생:', error)
  } finally {
    // 프로세스 종료
    process.exit(0)
  }
}

// 스크립트 실행
seedData()declare global {
    namespace NodeJS {
      interface ProcessEnv {
        NEXT_PUBLIC_FIREBASE_API_KEY: string;
        NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: string;
        NEXT_PUBLIC_FIREBASE_PROJECT_ID: string;
        NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: string;
        NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: string;
        NEXT_PUBLIC_FIREBASE_APP_ID: string;
        [key: string]: string | undefined;
      }
    }
  }
  
  export {}import { Timestamp } from 'firebase/firestore'

// Firestore에서 사용할 정확한 타입 정의
export interface FirestoreUser {
  // Auth (인증)
  uid: string                    // PK, document ID와 동일
  email: string                  // 이메일 (Firebase Auth와 동일)
  role: 'super_admin' | 'admin' | 'user'         // 권한
  status: 'active' | 'inactive' | 'pending'  // 계정 상태
  lastLoginAt: Timestamp         // 마지막 로그인 (Firestore Timestamp)

  // Profile (프로필)
  name: string                   // 이름
  phone: string | null          // 연락처 (optional)
  profileImage: string | null   // 프로필 이미지 URL (optional)

  // Organization (조직)
  department: string            // 부서
  position: string             // 직책
  corporationId: string    // 주 소속 법인 ID
  corporations: string[]   // 접근 가능한 법인 ID 목록

  // System (시스템)
  createdAt: Timestamp        // 생성일 (Firestore Timestamp)
  updatedAt: Timestamp        // 수정일 (Firestore Timestamp)
  createdBy: string          // 생성자 UID
  updatedBy: string          // 수정자 UID

  // 아바타 설정 추가
  avatarConfig?: {
    name: string
    variant: 'beam' | 'marble' | 'pixel' | 'sunset' | 'ring'
    colors: string[]
  }
}

// 생성 시 필요한 필수 필드 타입
export type CreateFirestoreUser = Omit<FirestoreUser, 
  'lastLoginAt' | 
  'createdAt' | 
  'updatedAt' | 
  'createdBy' | 
  'updatedBy'
> & {
  phone?: string
  profileImage?: string
  avatarConfig?: {
    name: string
    variant: 'beam' | 'marble' | 'pixel' | 'sunset' | 'ring'
    colors: string[]
  }
}// 현장 정보
export interface Site {
    id: string;         // id 추가
    code: string;        // 현장코드
    name: string;        // 현장명
    status: 'ACTIVE' | 'COMPLETED';
    startDate: Date;     // 착공일
    endDate?: Date;      // 준공일
  }
  
  // 거래처 정보
  export interface Vendor {
    id: string;
    businessNumber: string;  // 사업자번호
    name: string;           // 거래처명
    status: 'ACTIVE' | 'INACTIVE';
  }
  
  // 결재 요청 폼 데이터
  export interface PaymentRequestFormData {
    siteId: string;
    vendorId: string;
    title: string;
    amount: number;
    description: string;
    requestDate: string;
    dueDate: string;
    attachments?: File[];
  }
  
  // 결재 요청
  export interface PaymentRequest {
    id: string;
    requestNumber: string;     // 7자리 관리번호
    siteCode: string;         // 현장코드
    siteName: string;         // 현장명
    vendorId: string;        // 거래처 ID
    vendorName: string;      // 거래처명
    businessNumber: string;   // 사업자번호
    amount: number;          // 청구금액
    requestDate: Date;       // 청구일
    costType: 'COGS' | 'SGA'; // 비용구분
    costCategory: string;    // 세부 비용 항목
    status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'PAID';
    createdBy: string;      // 요청자 ID
    createdAt: Date;        // 생성일시
    updatedAt: Date;        // 수정일시
  }
  
  // 기존 타입 정의에 추가
  export type CostCategory = {
    code: string;
    name: string;
    type: 'COGS' | 'SGA';
  };
  
  export const COST_CATEGORIES: CostCategory[] = [
    // 매출원가 (COGS) 항목
    { code: 'MATERIAL', name: '자재비', type: 'COGS' },
    { code: 'LABOR', name: '노무비', type: 'COGS' },
    { code: 'OUTSOURCE', name: '외주비', type: 'COGS' },
    
    // 판관비 (SGA) 항목
    { code: 'SALARY', name: '급여', type: 'SGA' },
    { code: 'RENT', name: '임차료', type: 'SGA' },
    { code: 'UTILITY', name: '공과금', type: 'SGA' },
    { code: 'SUPPLIES', name: '소모품비', type: 'SGA' },
  ];import { FirebaseError } from 'firebase/app';

export const getFirebaseErrorMessage = (error: FirebaseError): string => {
  console.log('Firebase error code:', error.code); // 디버깅용
  
  switch (error.code) {
    case 'auth/invalid-credential':
      return '이메일 또는 비밀번호가 올바르지 않습니다';
    case 'auth/too-many-requests':
      return '너무 많은 로그인 시도가 있었습니다. 잠시 후 다시 시도해주세요';
    case 'auth/network-request-failed':
      return '네트워크 연결을 확인해주세요';
    case 'auth/internal-error':
      return '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요';
    default:
      console.error('Unhandled Firebase error:', error); // 디버깅용
      return '로그인에 실패했습니다. 다시 시도해주세요.';
  }
};
